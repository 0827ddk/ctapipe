import tables
import numpy as np
from ctapipe.core import Container, Item
from astropy.units import Quantity
from functools import partial
from collections import defaultdict

import logging
log = logging.getLogger(__name__)

PYTABLES_TYPE_MAP = {
    'float': tables.Float64Col,
    'float64': tables.Float64Col,
    'float32': tables.Float32Col,
    'int' : tables.IntCol,
    'bool': tables.BoolCol,
}



class SimpleHDF5TableWriter:
    """
    A very basic table writer that can take a container (or more than one) 
    and write it to an HDF5 file. It does _not_ recursively write the 
    container.
    
    This is a very simplistic implementation that only work on numpy array 
    fields in a `Container`, which must be initialized before the first call to 
    `write()`.
    
    It can write multiple tables at once, as long as you change the 
    table_name attribute to write() to specify which one to write to. Since 
    the data are copied to the row, speed may be an issue.
    
    Parameters:
    -----------
    filename: str
        name of hdf5 output file
    group_name: str
        name of group into which to put all of the tables generated by this 
        Writer (it will be placed under "/" in the file)
    """

    def __init__(self, filename, group_name):
        self._schemas = {}
        self._tables = {}
        self._transforms = defaultdict(dict)
        self._h5file = tables.open_file(filename, mode = "w")
        self._group = self._h5file.create_group("/", group_name)

    def __del__(self):
        self._h5file.close()

    def _create_schema(self, tablename, container):

        class Schema(tables.IsDescription):
            pass

        # create pytables schema description for the given container
        for colname, value in container.items():

            typename = ""
            shape = 1

            if isinstance(value, Quantity):
                req_unit = container.attributes[colname].unit
                if req_unit is not None:
                    tr = partial(_convert_and_strip_unit, unit=req_unit)
                else:
                    tr = lambda x: x.value

                value = tr(value)
                self.add_transform(tablename, colname, tr)

            if isinstance(value, np.ndarray):
                typename = value.dtype.name
                coltype = PYTABLES_TYPE_MAP[typename]
                shape = value.shape
                Schema.columns[colname] = coltype(shape=shape)

            elif type(value).__name__ in PYTABLES_TYPE_MAP:
                typename = type(value).__name__
                coltype = PYTABLES_TYPE_MAP[typename]
                Schema.columns[colname] = coltype()

            log.debug("Table {}: added col: {} type: {} shape: {}"\
                .format(tablename, colname, typename, shape))

        self._schemas[tablename] = Schema

    def add_transform(self, tablename, colname, transform):
        self._transforms[tablename][colname] = transform
        log.debug("Added transform: {}/{} -> {}".format(tablename, colname,
                                                        transform))

    def _create_table(self, tablename, title, metadata):
        table =  self._h5file.create_table(where=self._group,
                                           name=tablename,
                                           title=title,
                                           description=self._schemas[tablename])
        for key, val in metadata.items():
            table.attrs[key] = val

        self._tables[tablename] = table


    def write(self, tablename, container):
        """
        Write the contents of the given container to a table.  The first call 
        to write  will create a schema and initialize the table within the 
        file. The shape of data within the container must not change between 
        calls, since variable-length arrays are not supported. 
        
        Parameters
        ----------
        tablename: str 
            name of table to write to 
        container: `ctapipe.core.Container` 
            container to write
        """

        if tablename not in self._schemas:
            log.debug("Initializing table '{}'".format(tablename))
            self._create_schema(tablename, container)
            self._create_table(tablename,
                               container.__class__.__name__,
                               container.meta)

        # append a row to the table
        table = self._tables[tablename]
        row = table.row

        for colname in table.colnames:
            # apply value transform function if it exists for this column
            value = container[colname]

            log.debug("write: {} -> {}".format(colname, value))

            if colname in self._transforms[tablename]:
                tr = self._transforms[tablename][colname]
                value = tr(value)
            # set the data in the row
            row[colname] = value

        row.append()



def _convert_and_strip_unit(quantity, unit):
    return quantity.to(unit).value

