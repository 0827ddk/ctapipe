import tables
import numpy as np
from ctapipe.core import Container, Item
from astropy.units import Quantity
from functools import partial
from collections import defaultdict

import logging
log = logging.getLogger(__name__)

PYTABLES_TYPE_MAP = {
    'float': tables.Float64Col,
    'float64': tables.Float64Col,
    'float32': tables.Float32Col,
    'int' : tables.IntCol,
    'bool': tables.BoolCol,
}



class SimpleHDF5TableWriter:
    """
    A very basic table writer that can take a container (or more than one) 
    and write it to an HDF5 file. It does _not_ recursively write the 
    container. This is intended as a building block to create a more complex 
    I/O system. 
    
    It works by creating a HDF5 Table description from the `Items` inside a 
    container, where each item becomes a column in the table. The first time 
    `SimpleHDF5TableWriter.write()` is called, the container is registered 
    and the table created in the output file. 
    
    Each item in the container can also have an optional transform function 
    that is called before writing to transform the value.  For example, 
    unit quantities always have their units removed, or converted to a 
    common unit if specified in the `Item`. 
    
    Any metadata in the `Container` (stored in `Container.meta`) will be 
    written to the table's header on the first call to write() 
    
    Multiple tables may be written at once in a single file, as long as you 
    change the table_name attribute to write() to specify which one to write to. 
    
    Parameters:
    -----------
    filename: str
        name of hdf5 output file
    group_name: str
        name of group into which to put all of the tables generated by this 
        Writer (it will be placed under "/" in the file)
        
    """

    def __init__(self, filename, group_name):
        self._schemas = {}
        self._tables = {}
        self._transforms = defaultdict(dict)
        self._h5file = tables.open_file(filename, mode = "w")
        self._group = self._h5file.create_group("/", group_name)

    def __del__(self):
        self._h5file.close()

    def _create_schema(self, tablename, container):

        class Schema(tables.IsDescription):
            pass

        # create pytables schema description for the given container
        for colname, value in container.items():

            typename = ""
            shape = 1

            if isinstance(value, Quantity):
                req_unit = container.attributes[colname].unit
                if req_unit is not None:
                    tr = partial(_convert_and_strip_unit, unit=req_unit)
                else:
                    tr = lambda x: x.value

                value = tr(value)
                self.add_transform(tablename, colname, tr)

            if isinstance(value, np.ndarray):
                typename = value.dtype.name
                coltype = PYTABLES_TYPE_MAP[typename]
                shape = value.shape
                Schema.columns[colname] = coltype(shape=shape)

            elif type(value).__name__ in PYTABLES_TYPE_MAP:
                typename = type(value).__name__
                coltype = PYTABLES_TYPE_MAP[typename]
                Schema.columns[colname] = coltype()

            log.debug("Table {}: added col: {} type: {} shape: {}"\
                .format(tablename, colname, typename, shape))

        self._schemas[tablename] = Schema

    def add_transform(self, tablename, colname, transform):
        self._transforms[tablename][colname] = transform
        log.debug("Added transform: {}/{} -> {}".format(tablename, colname,
                                                        transform))

    def _create_table(self, tablename, title, metadata):
        table =  self._h5file.create_table(where=self._group,
                                           name=tablename,
                                           title=title,
                                           description=self._schemas[tablename])
        for key, val in metadata.items():
            table.attrs[key] = val

        self._tables[tablename] = table


    def write(self, tablename, container):
        """
        Write the contents of the given container to a table.  The first call 
        to write  will create a schema and initialize the table within the 
        file. The shape of data within the container must not change between 
        calls, since variable-length arrays are not supported. 
        
        Parameters
        ----------
        tablename: str 
            name of table to write to 
        container: `ctapipe.core.Container` 
            container to write
        """

        if tablename not in self._schemas:
            log.debug("Initializing table '{}'".format(tablename))
            self._create_schema(tablename, container)
            self._create_table(tablename,
                               container.__class__.__name__,
                               container.meta)

        # append a row to the table
        table = self._tables[tablename]
        row = table.row

        for colname in table.colnames:

            value = container[colname]

            # apply value transform function if it exists for this column
            if colname in self._transforms[tablename]:
                tr = self._transforms[tablename][colname]
                value = tr(value)

            row[colname] = value

        row.append()



def _convert_and_strip_unit(quantity, unit):
    return quantity.to(unit).value

